/* global ol */
'use strict';

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
var GeometryTypeControl = /*#__PURE__*/function (_ol$control$Control) {
  // Map control to switch type when geometry type is unknown
  function GeometryTypeControl(opt_options) {
    var _this;
    _classCallCheck(this, GeometryTypeControl);
    var options = opt_options || {};
    var element = document.createElement('div');
    element.className = 'switch-type type-' + options.type + ' ol-control ol-unselectable';
    if (options.active) {
      element.classList.add("type-active");
    }
    _this = _callSuper(this, GeometryTypeControl, [{
      element: element,
      target: options.target
    }]);
    var self = _this;
    var switchType = function switchType(e) {
      e.preventDefault();
      if (options.widget.currentGeometryType !== self) {
        options.widget.map.removeInteraction(options.widget.interactions.draw);
        options.widget.interactions.draw = new ol.interaction.Draw({
          features: options.widget.featureCollection,
          type: options.type
        });
        options.widget.map.addInteraction(options.widget.interactions.draw);
        options.widget.currentGeometryType.element.classList.remove('type-active');
        options.widget.currentGeometryType = self;
        element.classList.add("type-active");
      }
    };
    element.addEventListener('click', switchType, false);
    element.addEventListener('touchstart', switchType, false);
    return _this;
  }
  _inherits(GeometryTypeControl, _ol$control$Control);
  return _createClass(GeometryTypeControl);
}(ol.control.Control); // TODO: allow deleting individual features (#8972)
var MapWidget = /*#__PURE__*/function () {
  function MapWidget(options) {
    _classCallCheck(this, MapWidget);
    this.map = null;
    this.interactions = {
      draw: null,
      modify: null
    };
    this.typeChoices = false;
    this.ready = false;

    // Default options
    this.options = {
      default_lat: 0,
      default_lon: 0,
      default_zoom: 12,
      is_collection: options.geom_name.includes('Multi') || options.geom_name.includes('Collection')
    };

    // Altering using user-provided options
    for (var property in options) {
      if (Object.hasOwn(options, property)) {
        this.options[property] = options[property];
      }
    }
    if (!options.base_layer) {
      this.options.base_layer = new ol.layer.Tile({
        source: new ol.source.OSM()
      });
    }
    this.map = this.createMap();
    this.featureCollection = new ol.Collection();
    this.featureOverlay = new ol.layer.Vector({
      map: this.map,
      source: new ol.source.Vector({
        features: this.featureCollection,
        useSpatialIndex: false // improve performance
      }),
      updateWhileAnimating: true,
      // optional, for instant visual feedback
      updateWhileInteracting: true // optional, for instant visual feedback
    });

    // Populate and set handlers for the feature container
    var self = this;
    this.featureCollection.on('add', function (event) {
      var feature = event.element;
      feature.on('change', function () {
        self.serializeFeatures();
      });
      if (self.ready) {
        self.serializeFeatures();
        if (!self.options.is_collection) {
          self.disableDrawing(); // Only allow one feature at a time
        }
      }
    });
    var initial_value = document.getElementById(this.options.id).value;
    if (initial_value) {
      var jsonFormat = new ol.format.GeoJSON();
      var features = jsonFormat.readFeatures('{"type": "Feature", "geometry": ' + initial_value + '}');
      var extent = ol.extent.createEmpty();
      features.forEach(function (feature) {
        this.featureOverlay.getSource().addFeature(feature);
        ol.extent.extend(extent, feature.getGeometry().getExtent());
      }, this);
      // Center/zoom the map
      this.map.getView().fit(extent, {
        minResolution: 1
      });
    } else {
      this.map.getView().setCenter(this.defaultCenter());
    }
    this.createInteractions();
    if (initial_value && !this.options.is_collection) {
      this.disableDrawing();
    }
    var clearNode = document.getElementById(this.map.getTarget()).nextElementSibling;
    if (clearNode.classList.contains('clear_features')) {
      clearNode.querySelector('a').addEventListener('click', function (ev) {
        ev.preventDefault();
        self.clearFeatures();
      });
    }
    this.ready = true;
  }
  return _createClass(MapWidget, [{
    key: "createMap",
    value: function createMap() {
      return new ol.Map({
        target: this.options.map_id,
        layers: [this.options.base_layer],
        view: new ol.View({
          zoom: this.options.default_zoom
        })
      });
    }
  }, {
    key: "createInteractions",
    value: function createInteractions() {
      // Initialize the modify interaction
      this.interactions.modify = new ol.interaction.Modify({
        features: this.featureCollection,
        deleteCondition: function deleteCondition(event) {
          return ol.events.condition.shiftKeyOnly(event) && ol.events.condition.singleClick(event);
        }
      });

      // Initialize the draw interaction
      var geomType = this.options.geom_name;
      if (geomType === "Geometry" || geomType === "GeometryCollection") {
        // Default to Point, but create icons to switch type
        geomType = "Point";
        this.currentGeometryType = new GeometryTypeControl({
          widget: this,
          type: "Point",
          active: true
        });
        this.map.addControl(this.currentGeometryType);
        this.map.addControl(new GeometryTypeControl({
          widget: this,
          type: "LineString",
          active: false
        }));
        this.map.addControl(new GeometryTypeControl({
          widget: this,
          type: "Polygon",
          active: false
        }));
        this.typeChoices = true;
      }
      this.interactions.draw = new ol.interaction.Draw({
        features: this.featureCollection,
        type: geomType
      });
      this.map.addInteraction(this.interactions.draw);
      this.map.addInteraction(this.interactions.modify);
    }
  }, {
    key: "defaultCenter",
    value: function defaultCenter() {
      var center = [this.options.default_lon, this.options.default_lat];
      if (this.options.map_srid) {
        return ol.proj.transform(center, 'EPSG:4326', this.map.getView().getProjection());
      }
      return center;
    }
  }, {
    key: "enableDrawing",
    value: function enableDrawing() {
      this.interactions.draw.setActive(true);
      if (this.typeChoices) {
        // Show geometry type icons
        var divs = document.getElementsByClassName("switch-type");
        for (var i = 0; i !== divs.length; i++) {
          divs[i].style.visibility = "visible";
        }
      }
    }
  }, {
    key: "disableDrawing",
    value: function disableDrawing() {
      if (this.interactions.draw) {
        this.interactions.draw.setActive(false);
        if (this.typeChoices) {
          // Hide geometry type icons
          var divs = document.getElementsByClassName("switch-type");
          for (var i = 0; i !== divs.length; i++) {
            divs[i].style.visibility = "hidden";
          }
        }
      }
    }
  }, {
    key: "clearFeatures",
    value: function clearFeatures() {
      this.featureCollection.clear();
      // Empty textarea widget
      document.getElementById(this.options.id).value = '';
      this.enableDrawing();
    }
  }, {
    key: "serializeFeatures",
    value: function serializeFeatures() {
      // Three use cases: GeometryCollection, multigeometries, and single geometry
      var geometry = null;
      var features = this.featureOverlay.getSource().getFeatures();
      if (this.options.is_collection) {
        if (this.options.geom_name === "GeometryCollection") {
          var geometries = [];
          for (var i = 0; i < features.length; i++) {
            geometries.push(features[i].getGeometry());
          }
          geometry = new ol.geom.GeometryCollection(geometries);
        } else {
          geometry = features[0].getGeometry().clone();
          for (var j = 1; j < features.length; j++) {
            switch (geometry.getType()) {
              case "MultiPoint":
                geometry.appendPoint(features[j].getGeometry().getPoint(0));
                break;
              case "MultiLineString":
                geometry.appendLineString(features[j].getGeometry().getLineString(0));
                break;
              case "MultiPolygon":
                geometry.appendPolygon(features[j].getGeometry().getPolygon(0));
            }
          }
        }
      } else {
        if (features[0]) {
          geometry = features[0].getGeometry();
        }
      }
      var jsonFormat = new ol.format.GeoJSON();
      document.getElementById(this.options.id).value = jsonFormat.writeGeometry(geometry);
    }
  }]);
}();